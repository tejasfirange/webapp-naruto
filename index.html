<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Naruto-Themed World Map Prototype</title>
<style>
  :root{--ui-bg:rgba(10,10,10,0.6);--accent:#ffd166}
  body{margin:0; font-family:Inter, system-ui, Arial, sans-serif; background:#111; color:#eee; overflow:hidden}
  #game { position:relative; width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
  canvas{ background:#000; image-rendering:pixelated; box-shadow:0 8px 30px rgba(0,0,0,0.7); border-radius:8px }
  #ui { position:absolute; left:18px; bottom:18px; display:flex; gap:10px; align-items:center; }
  .dpad{ width:140px; height:140px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:6px; background:var(--ui-bg); padding:6px; border-radius:12px; }
  .dpad button{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; font-size:18px; border-radius:6px; cursor:pointer }
  .dpad button:active{ transform:translateY(1px); }
  #hud { position:absolute; right:18px; top:18px; background:var(--ui-bg); padding:12px 16px; border-radius:10px; font-size:14px }
  #minimap{ width:160px; height:160px; display:block; border-radius:6px; background:#000; margin-top:8px; image-rendering:pixelated; }
  #legend{ margin-top:8px; font-size:12px; color:#ddd }
  #controlsSmall{ position:absolute; left:18px; top:18px; background:var(--ui-bg); padding:8px 10px; border-radius:8px; font-size:13px }
  .label{ position:absolute; left:50%; transform:translateX(-50%); top:18px; color:#fff; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,0.7); font-size:20px }
  a.download { color:var(--accent); text-decoration:none; margin-left:8px }
  footer{ position:absolute; left:50%; transform:translateX(-50%); bottom:8px; font-size:12px; color:#bbb }
</style>
</head>
<body>
<div id="game">
  <canvas id="canvas" width="960" height="640"></canvas>
  <div class="label">Naruto-Themed World (Prototype)</div>

  <div id="ui">
    <div class="dpad" aria-hidden="true">
      <div></div><button id="up">▲</button><div></div>
      <button id="left">◀</button><div></div><button id="right">▶</button>
      <div></div><button id="down">▼</button><div></div>
    </div>
  </div>

  <div id="hud">
    <div><strong>Player</strong>: Centered</div>
    <canvas id="minimap"></canvas>
    <div id="legend">
      <div>Water • Forest • Grass • Sand • Mountain • Village</div>
    </div>
  </div>

  <div id="controlsSmall">Move: WASD / Arrow keys • Click map to teleport</div>
  <footer>Prototype map: use the arrows or WASD to explore. Player remains centered until edge.</footer>
</div>

<script>
/* ==== Configuration ==== */
const WORLD_SIZE = 500;               // 500x500 tiles
const TILE_SIZE = 8;                  // logical tile size in world px (render scaled)
const VIEW_TILES_X = 120;             // how many world tiles across the viewport (scaled)
const VIEW_TILES_Y = 80;              // vertical tiles
const CANVAS_W = 960, CANVAS_H = 640; // canvas physical size
const SEED = 12345;                   // seed for reproducible map

/* ==== Simple seeded value noise implementation ==== */
function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rnd = mulberry32(SEED);

/* Create a pseudo-noise grid using bilinear interpolation */
function generateValueNoise(w, h, scale, seedOffset=0) {
  const localRnd = mulberry32(SEED + seedOffset);
  // coarse grid
  const gridW = Math.ceil(w/scale)+1, gridH = Math.ceil(h/scale)+1;
  const grid = Array.from({length:gridH}, () => Array.from({length:gridW}, ()=> localRnd()));
  function lerp(a,b,t){return a + (b-a)*t}
  const out = Array.from({length:h}, ()=> new Float32Array(w));
  for(let y=0;y<h;y++){
    const gy = y/scale;
    const iy = Math.floor(gy), fy = gy - iy;
    for(let x=0;x<w;x++){
      const gx = x/scale;
      const ix = Math.floor(gx), fx = gx - ix;
      const v00 = grid[iy][ix], v10 = grid[iy][ix+1], v01 = grid[iy+1][ix], v11 = grid[iy+1][ix+1];
      const ix0 = lerp(v00, v10, fx), ix1 = lerp(v01, v11, fx);
      out[y][x] = lerp(ix0, ix1, fy);
    }
  }
  return out;
}

/* ==== Map generation ==== */
const heightMap = generateValueNoise(WORLD_SIZE, WORLD_SIZE, 80, 0);
const moistureMap = generateValueNoise(WORLD_SIZE, WORLD_SIZE, 40, 7);
const featureMap = generateValueNoise(WORLD_SIZE, WORLD_SIZE, 18, 99);

const map = Array.from({length:WORLD_SIZE}, ()=> Array(WORLD_SIZE).fill(null));

function assignTiles() {
  for(let y=0;y<WORLD_SIZE;y++){
    for(let x=0;x<WORLD_SIZE;x++){
      const h = heightMap[y][x];      // 0..1
      const m = moistureMap[y][x];    // 0..1
      const f = featureMap[y][x];     // 0..1
      let tile = { type:'grass', sub:null, x, y };
      // bias to create interesting islands and continents
      if (h < 0.34) tile.type = 'water';
      else if (h < 0.36) tile.type = 'beach';
      else {
        if (m > 0.72 && h > 0.45) tile.type = 'forest';
        else if (m < 0.35 && h < 0.6) tile.type = 'sand';
        else if (h > 0.78) tile.type = 'mountain';
        else tile.type = 'grass';
      }
      // place villages and points of interest (naruto-themed)
      if (tile.type !== 'water' && f > 0.995 && Math.random() > 0.5) {
        tile.sub = 'village';
      } else if (tile.type === 'mountain' && f > 0.98) {
        tile.sub = 'cave';
      } else if (tile.type === 'forest' && f > 0.99) {
        tile.sub = 'shrine';
      }
      map[y][x] = tile;
    }
  }
}
assignTiles();

/* Add named regions (approximate) using rough rectangles */
const regions = [
  {name:'Land of Fire', x1:150, y1:180, x2:330, y2:360, color:'#2f5b1a'},
  {name:'Land of Water', x1:340, y1:40, x2:499, y2:200, color:'#1b6ea8'},
  {name:'Land of Wind', x1:10, y1:330, x2:140, y2:490, color:'#c89c52'},
  {name:'Land of Lightning', x1:360, y1:0, x2:499, y2:40, color:'#8393c6'},
  {name:'Land of Earth', x1:0, y1:0, x2:120, y2:140, color:'#9a7f4d'},
];

/* ==== Rendering ==== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap');
const mctx = minimap.getContext('2d');

let scale = 4; // pixels per tile on main canvas (rendered scaled)
let viewW = Math.floor(CANVAS_W / scale);
let viewH = Math.floor(CANVAS_H / scale);

let player = { x: Math.floor(WORLD_SIZE/2), y: Math.floor(WORLD_SIZE/2) };
let camera = { x: player.x - Math.floor(viewW/2), y: player.y - Math.floor(viewH/2) };

/* clamp camera */
function clampCamera() {
  camera.x = Math.max(0, Math.min(WORLD_SIZE - viewW, player.x - Math.floor(viewW/2)));
  camera.y = Math.max(0, Math.min(WORLD_SIZE - viewH, player.y - Math.floor(viewH/2)));
}

/* palette */
function terrainColor(t) {
  switch(t){
    case 'water': return '#0e4f6a';
    case 'beach': return '#e9cf76';
    case 'sand': return '#d9b38c';
    case 'forest': return '#2e6b34';
    case 'mountain': return '#6b5848';
    case 'grass': default: return '#4aa04a';
  }
}

/* draw small textured tile */
function drawTile(x,y,tile, sx, sy) {
  ctx.fillStyle = terrainColor(tile.type);
  ctx.fillRect(sx, sy, scale, scale);
  // small texture accents
  if (tile.type === 'forest' && Math.random() < 0.08) {
    ctx.fillStyle = '#1b3f1a';
    ctx.fillRect(sx + ( (x+y) % scale), sy + ((x*2+y) % scale), 1, 1);
  }
  if (tile.type === 'water') {
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(sx, sy, scale, Math.max(1, Math.floor(scale/6)));
  }
  if (tile.sub === 'village') {
    ctx.fillStyle = '#f6d365';
    ctx.fillRect(sx + Math.floor(scale/4), sy + Math.floor(scale/4), Math.max(1, Math.floor(scale/2)), Math.max(1, Math.floor(scale/2)));
  }
  if (tile.sub === 'cave') {
    ctx.fillStyle = '#222';
    ctx.fillRect(sx + Math.floor(scale/3), sy + Math.floor(scale/3), Math.max(1, Math.floor(scale/3)), Math.max(1, Math.floor(scale/3)));
  }
  if (tile.sub === 'shrine') {
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(sx + Math.floor(scale/3), sy + Math.floor(scale/3), Math.max(1, Math.floor(scale/3)), Math.max(1, Math.floor(scale/3)));
  }
}

/* draw region overlay labels */
function drawRegionLabels() {
  ctx.font = "18px serif";
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.textAlign = 'center';
  regions.forEach(r=>{
    const cx = Math.floor((r.x1 + r.x2)/2), cy = Math.floor((r.y1 + r.y2)/2);
    const sx = (cx - camera.x) * scale + scale/2;
    const sy = (cy - camera.y) * scale + scale/2;
    if (sx > -100 && sx < CANVAS_W + 100 && sy > -100 && sy < CANVAS_H + 100) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillText(r.name, sx+1, sy+1);
      ctx.fillStyle = r.color;
      ctx.fillText(r.name, sx, sy);
    }
  });
}

/* main draw function */
function draw() {
  ctx.clearRect(0,0,CANVAS_W, CANVAS_H);
  // draw tiles in view
  for(let y=0;y<viewH;y++){
    for(let x=0;x<viewW;x++){
      const wx = camera.x + x, wy = camera.y + y;
      if (wx < 0 || wy < 0 || wx >= WORLD_SIZE || wy >= WORLD_SIZE) {
        ctx.fillStyle = '#000';
        ctx.fillRect(x*scale, y*scale, scale, scale);
        continue;
      }
      drawTile(wx, wy, map[wy][wx], x*scale, y*scale);
    }
  }
  // draw player center marker
  const pcx = Math.floor((player.x - camera.x) * scale + scale/2);
  const pcy = Math.floor((player.y - camera.y) * scale + scale/2);
  ctx.beginPath();
  ctx.fillStyle = '#ff6b6b';
  ctx.arc(pcx, pcy, Math.max(2, scale*0.9), 0, Math.PI*2);
  ctx.fill();
  // draw region labels
  drawRegionLabels();
  // draw slight vignette & border
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = 3;
  ctx.strokeRect(0.5,0.5,CANVAS_W-1,CANVAS_H-1);
  // minimap update
  drawMinimap();
}

/* draw minimap (scaled down) */
function drawMinimap() {
  const mmW = minimap.width, mmH = minimap.height;
  mctx.clearRect(0,0,mmW,mmH);
  const sx = Math.floor(mmW / WORLD_SIZE), sy = Math.floor(mmH / WORLD_SIZE);
  // draw coarse blocks for performance
  const step = Math.max(1, Math.floor(WORLD_SIZE / mmW));
  for(let y=0;y<WORLD_SIZE;y+=step){
    for(let x=0;x<WORLD_SIZE;x+=step){
      const tile = map[y][x];
      mctx.fillStyle = terrainColor(tile.type);
      mctx.fillRect(Math.floor(x / WORLD_SIZE * mmW), Math.floor(y / WORLD_SIZE * mmH), Math.ceil(mmW / (WORLD_SIZE/step)), Math.ceil(mmH / (WORLD_SIZE/step)));
    }
  }
  // player marker
  mctx.fillStyle = '#ff6b6b';
  const px = Math.floor(player.x / WORLD_SIZE * mmW), py = Math.floor(player.y / WORLD_SIZE * mmH);
  mctx.fillRect(px-1, py-1, 3, 3);
}

/* ==== Controls & Movement ==== */
const keys = {};
window.addEventListener('keydown', (e)=>{
  keys[e.key.toLowerCase()] = true;
  e.preventDefault();
});
window.addEventListener('keyup', (e)=>{
  keys[e.key.toLowerCase()] = false;
});

function stepMovement() {
  let mx=0,my=0;
  if (keys['w'] || keys['arrowup']) my -= 1;
  if (keys['s'] || keys['arrowdown']) my += 1;
  if (keys['a'] || keys['arrowleft']) mx -= 1;
  if (keys['d'] || keys['arrowright']) mx += 1;
  if (mx !== 0 || my !== 0) {
    // move player but keep inside bounds
    player.x = Math.max(0, Math.min(WORLD_SIZE-1, player.x + mx));
    player.y = Math.max(0, Math.min(WORLD_SIZE-1, player.y + my));
    clampCamera();
  }
}

/* UI buttons */
document.getElementById('up').addEventListener('mousedown', ()=>{ keys['arrowup']=true });
document.getElementById('up').addEventListener('mouseup', ()=>{ keys['arrowup']=false });
document.getElementById('down').addEventListener('mousedown', ()=>{ keys['arrowdown']=true });
document.getElementById('down').addEventListener('mouseup', ()=>{ keys['arrowdown']=false });
document.getElementById('left').addEventListener('mousedown', ()=>{ keys['arrowleft']=true });
document.getElementById('left').addEventListener('mouseup', ()=>{ keys['arrowleft']=false });
document.getElementById('right').addEventListener('mousedown', ()=>{ keys['arrowright']=true });
document.getElementById('right').addEventListener('mouseup', ()=>{ keys['arrowright']=false });

/* click to teleport for quick demo */
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  const tileX = camera.x + Math.floor(cx / scale), tileY = camera.y + Math.floor(cy / scale);
  player.x = Math.max(0, Math.min(WORLD_SIZE-1, tileX)); player.y = Math.max(0, Math.min(WORLD_SIZE-1, tileY));
  clampCamera();
  draw();
});

/* responsive scaling: adjust viewW/viewH based on scale & canvas */
function updateView() {
  viewW = Math.floor(CANVAS_W / scale);
  viewH = Math.floor(CANVAS_H / scale);
  clampCamera();
}

/* main loop */
function mainLoop() {
  stepMovement();
  draw();
  requestAnimationFrame(mainLoop);
}

/* initialize minimap resolution */
minimap.width = 160; minimap.height = 160;

/* init camera and start */
clampCamera();
mainLoop();

</script>
</body>
</html>
